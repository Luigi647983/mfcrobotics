<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Demo 3D Avanzata Gripper</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.164.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.164.0/examples/js/controls/OrbitControls.js"></script>
<style>
  body { margin:0; background:black; overflow:hidden; }
  #gripper-demo { width:100%; height:100vh; display:block; }
  .controls { position:absolute; bottom:20px; width:100%; text-align:center; color:white; font-family:sans-serif; }
  input[type=range] { width:200px; }
</style>
</head>
<body>

<div id="gripper-demo"></div>

<div class="controls">
  <label>Apri/Chiudi: <input type="range" id="gripRange" min="0" max="1" step="0.01"></label>
</div>

<script>
const container = document.getElementById('gripper-demo');

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

// Camera
const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
camera.position.set(0, 1.2, 4);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 5);
scene.add(directionalLight);

// Gripper target object (simulazione oggetto da afferrare)
const targetGeometry = new THREE.SphereGeometry(0.1, 32, 32);
const targetMaterial = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive:0xff00ff, emissiveIntensity:0.5 });
const target = new THREE.Mesh(targetGeometry, targetMaterial);
target.position.set(0, 0, 0);
scene.add(target);

// Particelle orbitanti
const particleCount = 150;
const particles = new THREE.BufferGeometry();
const positions = [];
const angles = [];
for(let i=0; i<particleCount; i++){
    const radius = Math.random()*1.5 + 0.5;
    const angle = Math.random()*Math.PI*2;
    angles.push(angle);
    positions.push(radius*Math.cos(angle), Math.random()*1.5-0.5, radius*Math.sin(angle));
}
particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
particles.userData = { angles, radii: positions.filter((_,i)=>i%3==0).map((x)=>Math.sqrt(x*x + x*x)) }; // radius placeholder
const particleMaterial = new THREE.PointsMaterial({ color:0x00ffff, size:0.03, transparent:true, opacity:0.6 });
const particleSystem = new THREE.Points(particles, particleMaterial);
scene.add(particleSystem);

// Load Gripper 3D model
let gripper;
const loader = new THREE.GLTFLoader();
loader.load('gripper.glb', (gltf)=>{
    gripper = gltf.scene;
    scene.add(gripper);
    gripper.scale.set(1,1,1);
    gripper.position.set(0,0,0);

    // Glow neon sulle chele
    gripper.traverse((child)=>{
        if(child.isMesh){
            child.material.emissive = new THREE.Color(0x00ffff);
            child.material.emissiveIntensity = 0.3;
        }
    });

    animate();
});

// Resize
window.addEventListener('resize', ()=>{
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
});

// Animate
function animate(){
    requestAnimationFrame(animate);

    controls.update();

    // Rotazione lenta del gripper
    if(gripper) gripper.rotation.y += 0.003;

    // Glow pulsante sincronizzato con apertura
    const sliderValue = parseFloat(document.getElementById('gripRange').value);
    if(gripper) gripper.traverse((child)=>{
        if(child.isMesh) child.material.emissiveIntensity = 0.3 + sliderValue*0.5;
    });

    // Particelle orbitanti intorno al gripper
    const positions = particleSystem.geometry.attributes.position.array;
    for(let i=0; i<particleCount; i++){
        const index = i*3;
        const radius = Math.sqrt(positions[index]*positions[index] + positions[index+2]*positions[index+2]);
        const angle = angles[i] + 0.01;
        angles[i] = angle;
        positions[index] = radius * Math.cos(angle);
        positions[index+2] = radius * Math.sin(angle);
    }
    particleSystem.geometry.attributes.position.needsUpdate = true;

    renderer.render(scene, camera);
}

// Interactivity: slider apertura/chiusura
const slider = document.getElementById('gripRange');
slider.addEventListener('input', ()=>{
    if(!gripper) return;

    const leftClaw = gripper.getObjectByName('LeftClaw');
    const rightClaw = gripper.getObjectByName('RightClaw');

    const angle = slider.value * 0.5; // 0=chiuso, 1=aperto

    if(leftClaw) leftClaw.rotation.y = angle;
    if(rightClaw) rightClaw.rotation.y = -angle;

    // Simulazione presa dell'oggetto
    if(slider.value > 0.8){
        target.position.set(0,0,0.1); // leggermente "afferra" l'oggetto
    } else {
        target.position.set(0,0,0);
    }
});
</script>

</body>
</html>
